===========================================================================

http://games.cs.washington.edu/verigame/world1.html

===========================================================================

DARPA people:
Drew Dean
John Cheng (technical SETA)

===========================================================================

Verigames simplifications (optimizations) to perform:
 * peephole optimizations
 * pinch points in a row (or dominated)
 * eliminate boards if never called AND has no pinch points
 * remove pipes?
 * remove stubs where the ball rolls to the end of a pipe (the pipe
   ends before the bottom of the board)
 * any pipe that is guaranteed to succeed
 * usused pipes (example: K in Map<K,V>?)
 * leave some easy stuff so people feel like they are making progress?
 * enable gradaton in scoring

===========================================================================

Verigames deliverables for Nat and Steph:
  file formats
  data structures
  hand-translated boards
  a complete and comprehensible algorithm that someone can code

We'll need these algorithms:
 * for user code:
    * program -> unoptimized network
    * network -> optimized network
 * for libraries:
    * annotated library -> optimized network



Verigames:  with only 2 values, why can't we solve the constraints in
linear time?  We can, if the constraints are solveable.

The answer is that the constraints are not solvable, in general.

The player needs to find a set of constraints that satisfies the tests but
not necessarily the type system.
Or, the player needs to find the place that an exception (cast) is needed.

----

Gameplay needs to specify when you drop a ball for type-based simulation.
Usually, but not always...

===========================================================================

Optimization ideas:
 * remove empty pipes, that Werner adds for convenience.

===========================================================================

Notes from meeting with Drew Dean, 8/9/2011:

The Director of DARPA is especially interested in modularity -- how to
break down a problem for crowdsourcing.  Here are some ways we can
crowdsource:
 * 1 person per level
 * possibly in parallel, with multiple people trying to solve each level
 * eventually, collaboratively on a single level (add chat feature)
 * each level can depend on, and thus use, results from other levels

===========================================================================

Drew would eventually like to run our tools on Apache, but it's written in
C.

Drew is also interested in incremental re-solving (when a small source code
modification is made after the previous version had been verified).

