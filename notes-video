===========================================================================

Drew Dean wants a short video of 2-3 minutes that focuses on
 * how the problem is solved today (command-line tool)
 * gameplay, including:
    * basic mechanics
    * what people are thinking about when solving the game
    * switching between boards within a level
    * advancing between levels within a game
    * exceptions to the laws of physics
 * translation back to a verified program (use command-line tool to verify
   automatically-annotated program)

He prefers to handle the motivation, impacts, importance to the military,
etc. parts of the pitch.

===========================================================================

Proposed video script:

----

Caption:  Problem:  buggy, insecure software
Image:  [no good ideas.  Just a black background?  Show a hacker gaining
access to software, or a real-world effect of a (security) bug?]

[
I don’t think we can demo this in the video well.  drew needs to setup the
problem in general terms. would skip this altogether, or talk about it in terms
of how the probem is solved today.
]

[
I liked the example you gave in 331, where you had a real website that was
supposed to display content, but instead just said
java.lang.NullPointerException. Even for non-technical people, I think it's
pretty obvious that this is a failure. More obvious than, say, a stack trace of
a failing command-line tool. The fact that it's a failure on a website (which
is, obviously, exposed to the public) could hint at the potential security
gains that this project could result in, rather than just stability gains.
]

----

Caption:  How the problem is solved today

Video:
Show an editor buffer with code.
Opens a command line, runs a (pluggable) type-checker from the Checker Framework.
Lots of errors stream by.
Go to the editor, make a change, re-run the type-checker.

Voiceover:
A skilled programmer runs a program verification tool and incrementally
adds code annotations or fixes coding errors.  This process is slow and
uneconomic.

[
I think this needs to say something more.  For example, are we just speeding up
the slow process, or are we potentially solving stuff that cannot be solve
regardless of the resources poured on it.  I’m hoping it’s the second, as this
is a much more likely grounds for starting a new program.
]

----

Caption:
Our approach

Diagram:
code -> game -> play game -> verified software

Voiceover:
Our approach automatically converts a program verification problem into a
game that can be played in a browser or on a phone.  When a player finishes
the game, the final configuration of the level can be translated into a
proof of correctness for the original program.

[
I wonder if an alternative may be more effective: code -> game world->
large scale expertise development -> verified software

That way we are not just verifying software but building a very large
population of experts that can over time do things faster more efficient,
and lead to solutions and perhaps even verification algorithms not
currently known.
]


[
I think it is important to mention here that anybody will be able to play the
game (and without having to know/understand the technical mechanics behind it),
that it's not just the same skilled programmers somehow having more fun while
doing the same thing. 
]

----

Voiceover: In the game, balls roll through a network of interconnected pipes.
Video: Chute.constructor, solved, with balls dropping through it (it's not
trivial, but not overwhelming, either).

Voiceover: There are narrow pipes and wide pipes, and there are small balls and
large balls.
Video: Intersection.getOutputChute, solved, with balls dropping through (it has
all four features described above, without too much else to distract).

Voiceover: A small ball can roll through any pipe.
Video: Intersection.factory, with top chutes narrow and bottom chute wide,
showing balls rolling

Voiceover: A large ball gets stuck if it tries to roll into a narrow pipe or
through a pinch point.
Video: Intersection.padToLength, with left chute narrow (small example of large
ball into narrow pipe), Boards.edgesSize unsolved (small example of pinch
point)

Voiceover: Your job is to make sure that no ball gets stuck.
Video: Stay on Boards.edgesSize, and show the click to change the chute size,
and the balls rolling successfully

[
This has to be shortened.  About half of the current size.  Start with the
goal: guide all balls so that they don’t get stuck.  Then say what you can
change..  then point to the trickiness.
]

[
there should be at least one mention
of the fact that boards can be nested and appear within one another at which
point I'll show the user mousing over a board and it being highlighted and then
clicked on and visited (animating from the side so that the audience sees that
it is actually another board in the level).

"A world is made up of levels, which consist of multiple boards. Each board can
include copies of other boards."
]

You can control the width of each pipe segment.  Click on a pipe segment to
change its width from wide to narrow or vice-versa.

[
Just an English consistency comment: In the previous section we call the player
"the player" and here we speak directly to the audience as the players with
"you". In the final draft, this should probably have consistent wording. 
]

The game is not trivial, because the player does not have complete freedom
to change widths.  Some pipes have pinch points, which are impassable by
large balls even if the pipe segment is wide.  And, some balls are always wide.

[
This section could potentially be introduced in a different order. So far we
have setup -> rules -> goal -> mechanics, so it's slightly disconnected to
introduce more rules now. Alternatively, the "your job ... no balls get stuck"
sentence could be moved into the "To solve the game..." paragraph to group all
the goal descriptions together. Or it could be put as the second sentence in
this whole section if it feels like we're going too long without giving the
audience an overall goal of the game.
]

The game consists of multiple boards in a level, and multiple levels in a
world.  A modification that makes progress on one board may cause a problem
on another board.  There may be multiple solutions.
[Show multiple solutions here.]

To solve the game, the player takes a high-level view of how the balls roll
through the pipe network, and the relationships among different parts of
the network.

When you finish a level, you move on to another level in the world.
Eventually, the entire world is solved.

----

Video:
Show the solved game and the program, on the same screen
Somehow transition to showing the solved game flowing into the program
The program obtains annotations, which can be highlighted in red.
Show the Checker Framework being run from the command line, with
"compilation succeeded" as the output.

Voiceover:
A solution to the game can be automatically converted into a proof of
correctness for the program.  More specifically, it is converted into a set
of annotations, which are akin to program specifications or contracts.
These annotations are guaranteed to be correct.  An external tool, called
the Checker Framework, can independently verify the program against them.

[
The middle sentence of this section may not be very clear to an audience that
is unfamiliar with code annotations/the Checker Framework. Perhaps something
more like "A solution to the game can be automatically converted back into
annotated source code, where the annotations specify properties of the code. An
external tool, called the Checker Framework, can independently use these
annotations to verify the program and produce a proof of correctness." -> That
may not be perfect either. I'm sure this entire script will go through several
iterations of wording.
]

[
I think this could be anticlimactic. I think it could detract from our point
that the game makes it simpler. I agree that we should show the end result
somehow, but I think cutting back to a programmer with his editor buffer and
shell could make it seem like the game didn't accomplish much.

I know this is more artificial, but what if we just showed a program working
correctly? Say we had an example buggy program at the beginning, and then we
show it executing properly at the end? Obviously, just verifying code doesn't
change its correctness, but detecting and fixing bugs is a goal of this
project, and it may be more gratifying to show something like that. However, we
do want to be sure that we're not misrepresenting the truth. 
]

----

[Discuss the mapping between program elements and game elements?]
[We don't have time for this in a 3-minute video.]

----

Show exceptions to the laws of physics

Voiceover:
If a player believes that a level is unsolvable, he can indicate the presence
of a problem using [tool name]. This marks a point of interest in the
underlying code, and a programmer will inspect it and correct the problem.


===========================================================================

Drew Dean agrees with my characterization of the video, below, and adds:

  Your impression is spot on, and the violating the laws of physics should
  lower the score (it would be nice if you could briefly work that into the
  video, if there are two solutions of which complies with the laws of
  physics and the other doesn't).

Video specifics

Drew-

We're working on the video you requested.  We want to make sure it fits
your needs, without wasting our time.

There are a lot of points that could be made in your pitch and/or the
video, such as:
 * statistics about security problems, and about the amount of existing
   code that has not been verified
 * possibility of a pan-university student competition to resolve as much
   of the Linux kernel as possible
 * list of security bugs that could be addressed with slight
   modification of the framework

My impression (but please correct me if I am wrong!) is that you want a
short video that focuses on
 * how the problem is solved today (command-line tool)
 * gameplay, including:
    * basic mechanics
    * what people are thinking about when solving the game
    * switching between boards within a level
    * advancing between levels within a game
 * translation back to a verified program (use command-line tool to verify
   automatically-annotated program)

My impression is that you prefer to handle the motivation, impacts,
importance to the military, etc. parts of the pitch.

There are some intermediate topics that could be included or excluded:
 * collaboration aspects that enable teams to work together through problem
   subdivision or re-solving partially solved problems.
 * human insight into insoluble problems:  exceptions to the rules of
   physics show a programmer where to focus.

If you can please offer some guidance, that would be a big help in
preventing us from creating a beautiful and compelling video that isn't
what you want or need.

Thanks!
                    -Mike

===========================================================================

Zoran's proposal:

1.       introduction on the current way these bugs are tracked, either through
some emacs buffer thing, or the output of the state-of-the-art code checker.

2.       Point to some jaw dropping statistics on important code used daily
without any certainty of robustness.  Make it security heavy because that’s
what they want to hear.

3.       A didactic example of play introducing the basic mechanics and what
the user is thinking about when solving the puzzle

4.       Switch to a more complex example with nesting, dependency of pipes
across multiple frames, etc.

5.       Point to a collaborative aspect that enables teams to work together
through problem subdivision or resolving partially solved problems.

6.       Show a largeish code base that we were able to resolve (if that
actually is the case).

7.       Point to a possibility of a pan-univresity student competition to
resolve as much of the linux kernel as possible

8.       Show a list of top 25 security bugs that could be addressed with
slight modification of the framework

9.       (optional) point to other problems like threading etc that would need
to be addressed with the larger program just so it does not look like we’ve
already solved it, so that they feel justify to fund the program for at least
3-4 years.

What works best (from our countless siggraph video experiences) is writing out
all the text first, making sure that it work fits in the planned time, and then
generate video cuts that fit optimally with text.  I suggest we work on that as
woon as we agree on the rough outline.  Please add items to this list, suggest
removal or edit.  Seth could you create a google doc  so that all comments and
edits are tracked.

===========================================================================

1. I think one needs to think carefully about what one is contrasting 
between verification today vs verification w/ games.  Your script is not 
clear about that because it could be that
     - command line tools are used today for verification -> games are 
more visual
     - a verification expert is need for verification -> games can be 
played by anyone
     - verification is boring and tedious -> games are fun (and 
potentially instructive)
     - verification doesn't scale (for many reasons) -> distributed 
games scale with the number of players
     - ...
     - some or all of the above

I agree with your first point, that we should be more explicit about the
benefits of the game. I believe that all of the points you listed are valid,
though I'm not sure how many we can feasibly work into the video.

I agree.  I believe Drew wants to motivate a new approach to verification based
on crowd sourcing.  With one picture (lone person sitting in front of a
command-line interface tool) one could all points (with the voiceover and
carefully chosen words). 


2. I still don't see the connection between making all the pipes green 
and the proof/verification result.  In other words, I can play the game 
and make all the pipes green without knowing anything about verification.

As for your second, I'm not sure if I understand what you're saying. I would
say that the *point* of the game is that you can play it without understanding
the connection to verification. If you can solve the whole level without
knowing anything about the code it came from, we've done our jobs. Or were you
asking for an explanation about the relationship between green pipes and
verified code for your own benefit?


3. Who makes up the game?  Isn't making up the game as hard as finding 
the proof?

Lastly, just to clarify, the end goal is to have the translation from code to
game levels be completely automated. We will not need to do a hand translation
of all the code. You're right that that requires orders of magnitude more time
and a much deeper understanding than simply adding annotations to code.

===========================================================================
