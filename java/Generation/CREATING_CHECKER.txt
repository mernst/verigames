--------------------------------------------------------------------------------
Creating a type system for use with Verigames
--------------------------------------------------------------------------------

Nathaniel Mote (November 2013)

Throughout this document, I will use the nonnegative checker for examples. It is
simple and self-contained, yet it has enough functionality that it should be
easy to generalize it to other cases.

--------------------------------------------------------------------------------
1. Decide on properties that you would like your type system to have. For
example, for the nonnegative checker, the properties follow:
--------------------------------------------------------------------------------

Two type annotations: UnknownSign and NonNegative. NonNegative is a subtype of
UnknownSign.

Properties:
- All normal subtyping properties
- Array indices must be NonNegative
- NonNegative + NonNegative ==> NonNegative
- NonNegative * NonNegative ==> NonNegative
- NonNegative / NonNegative ==> NonNegative (div by zero is a separate problem)

We can also add an annotated JDK stubfile, which will allow us, for example, to
require that List.get() take a NonNegative.

--------------------------------------------------------------------------------
2. Create the qualifiers for the type system as described in the
checker-framework manual:
--------------------------------------------------------------------------------

http://types.cs.washington.edu/checker-framework/current/checkers-manual.html#writing-a-checker

This will also allow us to take advantage of built in subtyping rules without
any additional effort.

--------------------------------------------------------------------------------
3. Create a Checker class.
--------------------------------------------------------------------------------

A Checker class contains boilerplate code expressing basic information about a
type system.

It should extend games.GameChecker, since we intend to use it in a game. The
GameChecker provides some behavior common to all game type systems.

It is useful to create fields, of type AnnotationMirror, corresponding to the
annotations in your type system. An AnnotationMirror is the compiler's
representation of an annotation (see
http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/AnnotationMirror.html). For example, to get an AnnotationMirror from the class literal for an annotation, you could write:

javacutils.AnnotationUtils.fromClass(processingEnv.getElementUtils(),
    NonNegative.class)

The class should override the initChecker() method to set these fields.

An AnnotatedTypeMirror is the jsr308 compiler's representation for a type,
including its annotations. It is based on the standard compiler's TypeMirror,
which represents a type. See
http://types.cs.washington.edu/checker-framework/current/api/checkers/types/AnnotatedTypeMirror.html
and
http://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeMirror.html

Other methods to override:
- createInferenceVisitor()
  - return the visitor for your type checker (see the next section). For the
    NonNegative checker, I return an instance of NonNegativeVisitor.
- needsAnnotation(AnnotatedTypeMirror)
  - I just return false, and it appears to work
- defaultQualifier()
  - from the name, I assume it's the default qualifier to apply to everything. I
    return UnknownSign, since it's the supertype.
- defaultQualifier(AnnotatedTypeMirror)
  - also not sure, I just return the defaultQualifier()
- selfQualifier()
  - supposedly is never used -- don't worry about it
- withCombineConstraints()
  - just return false, apparently they aren't really supported at the moment,
    and Jonathan doesn't know what they are either.

--------------------------------------------------------------------------------
4. Create a Visitor class
--------------------------------------------------------------------------------

Your visitor class provides a little bit more configuration boilerplate, and
defines any special requirements that your type system introduces.

For example, in the NonNegativeVisitor, the requirement that array indices be
NonNegative is enforced.

Your Visitor class should extend games.GameVisitor, with your Checker class as a
type parameter.

Your visitor will be an indirect subclass of the checker framework's
SourceVisitor. See
http://types.cs.washington.edu/checker-framework/current/api/checkers/source/SourceVisitor.html

Methods:
- Constructor:
  - Three arguments: <your checker class> ichecker, InferenceChecker ichecker,
    boolean infer
  - I do not know what these parameters do, just pass them to the superclass.
  - When instantiating it, provide an instance of your checker, null, and false.

- override createRealTypeFactory
  - Simply return a new instance of your AnnotatedTypeFactory (see next section)

- any visitor methods you must override to implement your type system's rules.
  - For example, the NonNegativeVisitor overrides visitArrayAccess.
  - For any constraints that you wish to enforce, call the mainIsNot method with the following arguments:
    - the AnnotatedTypeMirror for which you would like to assert some property
      (typically retrieved by using your AnnotatedTypeFactory and passing in a
      Tree)
    - The AnnotationMirror that you wish the type to have.
    - An error message String
    - The Tree object that you gave to the AnnotationMirror to get the first
      argument.
  - You may find the documentation for trees useful:
    http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/package-summary.html
  - You may also find the SourceVisitor documentation (linked above) useful --
    it lists all of the visitor methods that can be overridden.

--------------------------------------------------------------------------------
5. Create an AnnotatedTypeFactory
--------------------------------------------------------------------------------

The AnnotatedTypeFactory is what the typechecker uses to find the type of a
given AST tree node. Here, you will define any special rules for determining the
type of a given tree node. For example, the NonNegative checker automatically
assigns the NonNegative type to any nonnegative integer literals, and also to
the addition, multiplication, or division of any two NonNegative integers. These
properties are implemented in the NonNegativeAnnotatedTypeFactory.

TODO finish this section
