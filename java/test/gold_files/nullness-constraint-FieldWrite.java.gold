Constraints:
SubtypeConstraint( Constant(@nninf.quals.Nullable)  <:  Variable 0 at class FieldWrite extends type; tree <<missing tree>> within 
class FieldWrite {
    
    FieldWrite() {
        super();
    }
    Object f;
    
    void m() {
        f = new Object();
    }
    
    void n() {
        f = null;
    }
} )

SubtypeConstraint( Variable 1 at method FieldWrite#<init>():V return type; tree 
<init>() {
    super();
}  <:  Variable 0 at class FieldWrite extends type; tree <<missing tree>> within 
class FieldWrite {
    
    FieldWrite() {
        super();
    }
    Object f;
    
    void m() {
        f = new Object();
    }
    
    void n() {
        f = null;
    }
} )

StubBoardUseConstraint(java.lang.Object,java.lang.Object#<init>():void,method FieldWrite#<init>():V constraint position,null,List(),List(),List(),List(),List(),List(Constant(@nninf.quals.Nullable)))

checkers.inference.InstanceMethodCallConstraint(
contextVp: method FieldWrite#<init>():V constraint position; 
calledVp: None; 
receiver: null; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Constant(@nninf.quals.Nullable)); 
)

SubtypeConstraint( Variable 2 at method FieldWrite#m():V receiver; tree <<missing tree>> within 
void m() {
    f = new Object();
}Atm: @VarAnnot(2) FieldWrite  <:  Variable 0 at class FieldWrite extends type; tree <<missing tree>> within 
class FieldWrite {
    
    FieldWrite() {
        super();
    }
    Object f;
    
    void m() {
        f = new Object();
    }
    
    void n() {
        f = null;
    }
} )

checkers.inference.InstanceMethodCallConstraint(
contextVp: method FieldWrite#m():V constraint position; 
calledVp: None; 
receiver: null; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Constant(@nninf.quals.Nullable)); 
)

InequalityConstraint( context: method FieldWrite#m():V constraint position, Variable 5 at method FieldWrite#m():V creation 0; tree Object != Constant(@nninf.quals.Nullable) )

SubtypeConstraint( RefinementVariable #6 Declared Variable: Variable 4 at class FieldWrite field f; tree Object IfTest: false mergedTo: (Set())  <:  Variable 4 at class FieldWrite field f; tree Object )

checkers.inference.FieldAssignmentConstraint(
contextVp: method FieldWrite#m():V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 2 at method FieldWrite#m():V receiver; tree <<missing tree>> within 
void m() {
    f = new Object();
}Atm: @VarAnnot(2) FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Variable 5 at method FieldWrite#m():V creation 0; tree Object ); 
result: List(); 
)

EqualityConstraint( RefinementVariable #6 Declared Variable: Variable 4 at class FieldWrite field f; tree Object IfTest: false mergedTo: (Set()) = Variable 5 at method FieldWrite#m():V creation 0; tree Object )

SubtypeConstraint( Variable 5 at method FieldWrite#m():V creation 0; tree Object  <:  Variable 4 at class FieldWrite field f; tree Object )

SubtypeConstraint( Variable 3 at method FieldWrite#n():V receiver; tree <<missing tree>> within 
void n() {
    f = null;
}Atm: @VarAnnot(3) FieldWrite  <:  Variable 0 at class FieldWrite extends type; tree <<missing tree>> within 
class FieldWrite {
    
    FieldWrite() {
        super();
    }
    Object f;
    
    void m() {
        f = new Object();
    }
    
    void n() {
        f = null;
    }
} )

SubtypeConstraint( RefinementVariable #7 Declared Variable: Variable 4 at class FieldWrite field f; tree Object IfTest: false mergedTo: (Set())  <:  Variable 4 at class FieldWrite field f; tree Object )

checkers.inference.FieldAssignmentConstraint(
contextVp: method FieldWrite#n():V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 3 at method FieldWrite#n():V receiver; tree <<missing tree>> within 
void n() {
    f = null;
}Atm: @VarAnnot(3) FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Literal(NULL_LITERAL, "null") ); 
result: List(); 
)

EqualityConstraint( RefinementVariable #7 Declared Variable: Variable 4 at class FieldWrite field f; tree Object IfTest: false mergedTo: (Set()) = Literal(NULL_LITERAL, "null") )

SubtypeConstraint( Literal(NULL_LITERAL, "null")  <:  Variable 4 at class FieldWrite field f; tree Object )

SubtypeConstraint( Constant(@nninf.quals.Nullable)  <:  Variable 8 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

SubtypeConstraint( Variable 9 at method FWOther#<init>():V return type; tree 
<init>() {
    super();
}  <:  Variable 8 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

checkers.inference.InstanceMethodCallConstraint(
contextVp: method FWOther#<init>():V constraint position; 
calledVp: None; 
receiver: null; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Constant(@nninf.quals.Nullable)); 
)

SubtypeConstraint( Variable 10 at method FWOther#write1():V receiver; tree <<missing tree>> within 
void write1() {
    fw.f = new Object();
    this.fw.f = null;
}Atm: @VarAnnot(10) FWOther  <:  Variable 8 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: Some(class FWOther field fw); 
receiver: Variable 10 at method FWOther#write1():V receiver; tree <<missing tree>> within 
void write1() {
    fw.f = new Object();
    this.fw.f = null;
}Atm: @VarAnnot(10) FWOther; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 14 at class FWOther field fw; tree FieldWrite); 
)

InequalityConstraint( context: method FWOther#write1():V constraint position, Variable 14 at class FWOther field fw; tree FieldWrite != Constant(@nninf.quals.Nullable) )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 14 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

checkers.inference.InstanceMethodCallConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: None; 
receiver: null; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Constant(@nninf.quals.Nullable)); 
)

InequalityConstraint( context: method FWOther#write1():V constraint position, Variable 15 at method FWOther#write1():V creation 0; tree Object != Constant(@nninf.quals.Nullable) )

SubtypeConstraint( Variable 15 at method FWOther#write1():V creation 0; tree Object  <:  Variable 4 at class FieldWrite field f; tree Object )

checkers.inference.FieldAssignmentConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 14 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Variable 15 at method FWOther#write1():V creation 0; tree Object ); 
result: List(); 
)

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: Some(class FWOther field fw); 
receiver: Variable 10 at method FWOther#write1():V receiver; tree <<missing tree>> within 
void write1() {
    fw.f = new Object();
    this.fw.f = null;
}Atm: @VarAnnot(10) FWOther; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 14 at class FWOther field fw; tree FieldWrite); 
)

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 14 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

checkers.inference.FieldAssignmentConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 14 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Literal(NULL_LITERAL, "null") ); 
result: List(); 
)

SubtypeConstraint( Variable 11 at method FWOther#read1():V receiver; tree <<missing tree>> within 
void read1() {
    Object x;
    x = fw.f;
    x = fw.f;
}Atm: @VarAnnot(11) FWOther  <:  Variable 8 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#read1():V constraint position; 
calledVp: Some(class FWOther field fw); 
receiver: Variable 11 at method FWOther#read1():V receiver; tree <<missing tree>> within 
void read1() {
    Object x;
    x = fw.f;
    x = fw.f;
}Atm: @VarAnnot(11) FWOther; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 14 at class FWOther field fw; tree FieldWrite); 
)

InequalityConstraint( context: method FWOther#read1():V constraint position, Variable 14 at class FWOther field fw; tree FieldWrite != Constant(@nninf.quals.Nullable) )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#read1():V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 14 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

EqualityConstraint( RefinementVariable #17 Declared Variable: Variable 16 at method FWOther#read1():V local variable x(0); tree Object IfTest: false mergedTo: (Set()) = Variable 4 at class FieldWrite field f; tree Object )

SubtypeConstraint( Variable 4 at class FieldWrite field f; tree Object  <:  Variable 16 at method FWOther#read1():V local variable x(0); tree Object )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#read1():V constraint position; 
calledVp: Some(class FWOther field fw); 
receiver: Variable 11 at method FWOther#read1():V receiver; tree <<missing tree>> within 
void read1() {
    Object x;
    x = fw.f;
    x = fw.f;
}Atm: @VarAnnot(11) FWOther; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 14 at class FWOther field fw; tree FieldWrite); 
)

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#read1():V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 14 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

EqualityConstraint( RefinementVariable #18 Declared Variable: Variable 16 at method FWOther#read1():V local variable x(0); tree Object IfTest: false mergedTo: (Set()) = Variable 4 at class FieldWrite field f; tree Object )

SubtypeConstraint( Variable 12 at method FWOther#write2(LFieldWrite;):V receiver; tree <<missing tree>> within 
void write2(FieldWrite p) {
    p.f = new Object();
    p.f = null;
}Atm: @VarAnnot(12) FWOther  <:  Variable 8 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

InequalityConstraint( context: method FWOther#write2(LFieldWrite;):V constraint position, Variable 13 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite != Constant(@nninf.quals.Nullable) )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 13 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

checkers.inference.InstanceMethodCallConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: None; 
receiver: null; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Constant(@nninf.quals.Nullable)); 
)

InequalityConstraint( context: method FWOther#write2(LFieldWrite;):V constraint position, Variable 19 at method FWOther#write2(LFieldWrite;):V creation 0; tree Object != Constant(@nninf.quals.Nullable) )

SubtypeConstraint( Variable 19 at method FWOther#write2(LFieldWrite;):V creation 0; tree Object  <:  Variable 4 at class FieldWrite field f; tree Object )

checkers.inference.FieldAssignmentConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 13 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Variable 19 at method FWOther#write2(LFieldWrite;):V creation 0; tree Object ); 
result: List(); 
)

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 13 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

checkers.inference.FieldAssignmentConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: Some(class FieldWrite field f); 
receiver: Variable 13 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Literal(NULL_LITERAL, "null") ); 
result: List(); 
)

