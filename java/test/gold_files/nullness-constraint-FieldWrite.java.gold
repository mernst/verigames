Constraints:
SubtypeConstraint( Constant(@nninf.quals.Nullable)  <:  Variable 0 at class FieldWrite extends type; tree <<missing tree>> within 
class FieldWrite {
    
    FieldWrite() {
        super();
    }
    Object f;
    
    void m() {
        f = new Object();
    }
    
    void n() {
        f = null;
    }
} )

SubtypeConstraint( Variable 1 at method FieldWrite#<init>():V return type; tree 
<init>() {
    super();
}  <:  Variable 0 at class FieldWrite extends type; tree <<missing tree>> within 
class FieldWrite {
    
    FieldWrite() {
        super();
    }
    Object f;
    
    void m() {
        f = new Object();
    }
    
    void n() {
        f = null;
    }
} )

SubtypeConstraint( Variable 2 at method FieldWrite#m():V receiver; tree <<missing tree>> within 
void m() {
    f = new Object();
}Atm: @VarAnnot(2) FieldWrite  <:  Variable 0 at class FieldWrite extends type; tree <<missing tree>> within 
class FieldWrite {
    
    FieldWrite() {
        super();
    }
    Object f;
    
    void m() {
        f = new Object();
    }
    
    void n() {
        f = null;
    }
} )

checkers.inference.FieldAccessConstraint(
contextVp: method FieldWrite#m():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 2 at method FieldWrite#m():V receiver; tree <<missing tree>> within 
void m() {
    f = new Object();
}Atm: @VarAnnot(2) FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

InequalityConstraint( context: method FieldWrite#m():V constraint position, Variable 5 at method FieldWrite#m():V creation 0; tree Object != Constant(@nninf.quals.Nullable) )

SubtypeConstraint( Variable 5 at method FieldWrite#m():V creation 0; tree Object  <:  Variable 4 at class FieldWrite field f; tree Object )

checkers.inference.FieldAssignmentConstraint(
contextVp: method FieldWrite#m():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 2 at method FieldWrite#m():V receiver; tree <<missing tree>> within 
void m() {
    f = new Object();
}Atm: @VarAnnot(2) FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Variable 5 at method FieldWrite#m():V creation 0; tree Object ); 
result: List(); 
)

SubtypeConstraint( Variable 3 at method FieldWrite#n():V receiver; tree <<missing tree>> within 
void n() {
    f = null;
}Atm: @VarAnnot(3) FieldWrite  <:  Variable 0 at class FieldWrite extends type; tree <<missing tree>> within 
class FieldWrite {
    
    FieldWrite() {
        super();
    }
    Object f;
    
    void m() {
        f = new Object();
    }
    
    void n() {
        f = null;
    }
} )

checkers.inference.FieldAccessConstraint(
contextVp: method FieldWrite#n():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 3 at method FieldWrite#n():V receiver; tree <<missing tree>> within 
void n() {
    f = null;
}Atm: @VarAnnot(3) FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

SubtypeConstraint( Literal(NULL_LITERAL, "null")  <:  Variable 4 at class FieldWrite field f; tree Object )

checkers.inference.FieldAssignmentConstraint(
contextVp: method FieldWrite#n():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 3 at method FieldWrite#n():V receiver; tree <<missing tree>> within 
void n() {
    f = null;
}Atm: @VarAnnot(3) FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Literal(NULL_LITERAL, "null") ); 
result: List(); 
)

SubtypeConstraint( Constant(@nninf.quals.Nullable)  <:  Variable 6 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

SubtypeConstraint( Variable 7 at method FWOther#<init>():V return type; tree 
<init>() {
    super();
}  <:  Variable 6 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

SubtypeConstraint( Variable 8 at method FWOther#write1():V receiver; tree <<missing tree>> within 
void write1() {
    fw.f = new Object();
    this.fw.f = null;
}Atm: @VarAnnot(8) FWOther  <:  Variable 6 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: class FWOther field fw; 
receiver: Variable 8 at method FWOther#write1():V receiver; tree <<missing tree>> within 
void write1() {
    fw.f = new Object();
    this.fw.f = null;
}Atm: @VarAnnot(8) FWOther; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 12 at class FWOther field fw; tree FieldWrite); 
)

InequalityConstraint( context: method FWOther#write1():V constraint position, Variable 12 at class FWOther field fw; tree FieldWrite != Constant(@nninf.quals.Nullable) )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 12 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

InequalityConstraint( context: method FWOther#write1():V constraint position, Variable 13 at method FWOther#write1():V creation 0; tree Object != Constant(@nninf.quals.Nullable) )

SubtypeConstraint( Variable 13 at method FWOther#write1():V creation 0; tree Object  <:  Variable 4 at class FieldWrite field f; tree Object )

checkers.inference.FieldAssignmentConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 12 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Variable 13 at method FWOther#write1():V creation 0; tree Object ); 
result: List(); 
)

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: class FWOther field fw; 
receiver: Variable 8 at method FWOther#write1():V receiver; tree <<missing tree>> within 
void write1() {
    fw.f = new Object();
    this.fw.f = null;
}Atm: @VarAnnot(8) FWOther; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 12 at class FWOther field fw; tree FieldWrite); 
)

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 12 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

checkers.inference.FieldAssignmentConstraint(
contextVp: method FWOther#write1():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 12 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Literal(NULL_LITERAL, "null") ); 
result: List(); 
)

SubtypeConstraint( Variable 9 at method FWOther#read1():V receiver; tree <<missing tree>> within 
void read1() {
    Object x;
    x = fw.f;
    x = fw.f;
}Atm: @VarAnnot(9) FWOther  <:  Variable 6 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#read1():V constraint position; 
calledVp: class FWOther field fw; 
receiver: Variable 9 at method FWOther#read1():V receiver; tree <<missing tree>> within 
void read1() {
    Object x;
    x = fw.f;
    x = fw.f;
}Atm: @VarAnnot(9) FWOther; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 12 at class FWOther field fw; tree FieldWrite); 
)

InequalityConstraint( context: method FWOther#read1():V constraint position, Variable 12 at class FWOther field fw; tree FieldWrite != Constant(@nninf.quals.Nullable) )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#read1():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 12 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

EqualityConstraint( RefinementVariable #15 Declared Variable: Variable 14 at method FWOther#read1():V local variable x(0); tree Object IfTest: false mergedTo: Set() = Variable 4 at class FieldWrite field f; tree Object )

SubtypeConstraint( Variable 4 at class FieldWrite field f; tree Object  <:  Variable 14 at method FWOther#read1():V local variable x(0); tree Object )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#read1():V constraint position; 
calledVp: class FWOther field fw; 
receiver: Variable 9 at method FWOther#read1():V receiver; tree <<missing tree>> within 
void read1() {
    Object x;
    x = fw.f;
    x = fw.f;
}Atm: @VarAnnot(9) FWOther; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 12 at class FWOther field fw; tree FieldWrite); 
)

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#read1():V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 12 at class FWOther field fw; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

EqualityConstraint( RefinementVariable #16 Declared Variable: Variable 14 at method FWOther#read1():V local variable x(0); tree Object IfTest: false mergedTo: Set() = Variable 4 at class FieldWrite field f; tree Object )

SubtypeConstraint( Variable 10 at method FWOther#write2(LFieldWrite;):V receiver; tree <<missing tree>> within 
void write2(FieldWrite p) {
    p.f = new Object();
    p.f = null;
}Atm: @VarAnnot(10) FWOther  <:  Variable 6 at class FWOther extends type; tree <<missing tree>> within 
class FWOther {
    
    FWOther() {
        super();
    }
    FieldWrite fw;
    
    void write1() {
        fw.f = new Object();
        this.fw.f = null;
    }
    
    void read1() {
        Object x;
        x = fw.f;
        x = fw.f;
    }
    
    void write2(FieldWrite p) {
        p.f = new Object();
        p.f = null;
    }
} )

InequalityConstraint( context: method FWOther#write2(LFieldWrite;):V constraint position, Variable 11 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite != Constant(@nninf.quals.Nullable) )

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 11 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

InequalityConstraint( context: method FWOther#write2(LFieldWrite;):V constraint position, Variable 17 at method FWOther#write2(LFieldWrite;):V creation 0; tree Object != Constant(@nninf.quals.Nullable) )

SubtypeConstraint( Variable 17 at method FWOther#write2(LFieldWrite;):V creation 0; tree Object  <:  Variable 4 at class FieldWrite field f; tree Object )

checkers.inference.FieldAssignmentConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 11 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Variable 17 at method FWOther#write2(LFieldWrite;):V creation 0; tree Object ); 
result: List(); 
)

checkers.inference.FieldAccessConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 11 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: (  ); 
result: List(Variable 4 at class FieldWrite field f; tree Object); 
)

checkers.inference.FieldAssignmentConstraint(
contextVp: method FWOther#write2(LFieldWrite;):V constraint position; 
calledVp: class FieldWrite field f; 
receiver: Variable 11 at method FWOther#write2(LFieldWrite;):V parameter 0; tree FieldWrite; 
methodTypeParamLBs: <  >; 
classTypeParamLBs: <  >; 
methodTypeArgs: <  >; 
classTypeArgs: <  >; 
args: ( Literal(NULL_LITERAL, "null") ); 
result: List(); 
)

