This document contains notes on how we want to map type systems to game worlds.

--------------------------------------------------------------------------------

Table of Contents

1. Game Overview
2. Concepts for Code-to-game Conversion
3. Details of Code-to-game Conversion
4. Future Work
5. Glossary

--------------------------------------------------------------------------------

1. Game Overview

We choose to map type systems consisting of only two types onto a puzzle game
made up of pipes and balls. An overview of the mapping follows:

Pipes correspond to a place in code where a type annotation can be written. A
wide pipe represents the more permissive of the two annotations (such as
Nullable in the nullness type system), and a narrow pipe represents the more
restrictive (such as NonNull).

Balls roll through pipes from top to bottom. A large ball gets stuck if it flows
from a large pipe into a narrow pipe. The player's goal is to prevent balls from
getting stuck by changing the width of the pipes. Often, the size of the balls
that are dropped into pipes change to match the width of a pipe. The game is
nontrivial because some balls stay large even if the pipe below them changes
width (resulting in a problem point), and some pipes cannot be made wide.

The width of the pipes when the game is solved correspond to the annotations
inserted back into the code.

Pipes can interact through merges (two pipes combine to become one) and splits
(one pipe splits into two).

Just as statements in a Java program are grouped into different methods and
classes, pipes are grouped into boards and levels. Each board is a single
rectangle consisting of a network of pipes, and representing a single method.

A level represents a class. It is a collection of boards, each of which
represent a method. The player can see thumbnails of the different boards and
can switch between them.

A world represents an entire program (or, alternatively, an interesting subset
of a program). It consists of a collection of levels that a user is able to move
through as she completes them.

If a player cannot complete a level, he has the option to place a buzz saw. A
buzz saw is placed on a pipe, and it transforms all large balls that flow
through it into small balls. This allows a player to remove trouble spots.
However, because this is not a real solution, players are discouraged from using
more buzz saws than necessary.

The effect of the buzz saw mechanic is that a player can identify situations in
which a solution is impossible (or difficult) and that information can be
reported back to the maintainers of the code on which the game is based.

--------------------------------------------------------------------------------

2. Concepts for Code-to-game Conversion

This section will summarize, conceptually, how Java code is translated into a
game world. The next section will describe the technical details of how this is
accomplished.

a. Pipes and Balls

Any place where a type annotation can be written is translated into a pipe (TODO
is this strictly correct? Are there places where type annotations can be written
that we do not generate pipes for?). Pipes can be linked, meaning that they are
necessarily of the same width. When two pipes are linked, changing the width of
one causes the width of the other to change, as well.

Note that because a pipe is generated for every place that a type annotation can
be written, a variable declaration can result in more than one pipe being
generated, if it includes type parameters. For example, (in most type systems)
the declaration "String foo;" would result in the generation of a single pipe,
whereas the statement "Map<String, Integer> bar;" would cause three pipes to be
generated (TODO find out if this is actually done right now).

TODO: paragraph on balls -- I (Nat) honestly don't understand what, exactly,
balls mean. They seem to be some strange hybrid of types and values, and (even
after years on the project) I have yet to put my finger on exactly what they
are. Are they just a visualizing aid or are they something more?

Pipes can interact with each other, just as variables in a program can. The
basic building blocks of pipe interaction are splits and merges.

A pipe can merge with another (such as when a conditional assignment occurs in
the code). When this happens, the balls flowing through them merge and the
resulting ball is the largest of the two.

Likewise, a pipe can split (this sometimes occurs when a variable is used). In
this case, the ball is cloned and sent down both pipes.

Based on the above, we can translate a few simple statements into a game part
for the nullness type system:

(this is not a full game, just as the statements below are not a full program)

String foo = "hello";
String bar = null;
String bar = foo;

-----------------------
|                     |
|   (foo)  (bar)      |
|                     |
|     o      O        |
|    | |    | |       |
|    |  \   |_|       |
|    | \ \            |
|    | |\ \           |
|    | | \ \          |
|    | |  \ \         |
|    | |   \ \        |
|    | |    | |       |
|    |_|    |_|       |
|                     |
-----------------------

Because foo is assigned a nonnull literal at its declaration, it starts with a
small ball. Because bar is assigned a null literal at its declaration, it starts
with a large ball. Because bar is assigned to, its previous pipe segment comes
to an end (because its old value is no longer used). foo's pipe splits -- the
left side continues on as before, but the right side becomes the pipe segment
representing foo. Once the variables go out of scope, their pipes are ended.

b. Boards and Subboards

Methods are translated into boards. A board is a single rectangle made up of
interconnected pipes.

Just as a method has arguments and return values, a board has input pipes and
output pipes. The input pipes are all of the pipes for the receiver and the
arguments, in order.

The outputs are all of the inputs (more on that below) and the pipe(s) for the
return type.

When a method is called, a subboard is inserted into that method's board. A
subboard is simply a thumbnail version of the board that represents the called
method. The inputs and outputs of the subboard are connected to the appropriate
pipes in the caller's board.

The reason that all of the input pipes are also output is that a method could
impose constraints on the pipe width, and we have decided that it should be
immediately obvious when a ball gets stuck in a subboard. So, instead of
splitting a variable's pipes, continuing them on one side, and connecting them
to the subboard, we simply connect them to the subboard and continue them at the
bottom, as though they simply passed through the subboard. (Note: actually,
currently the receiver is piped through and the rest of the arguments are split
and one side is connected to the top of the subboard.)

Additionally, this mechanic may help us when we introduce flow sensitivity (See
Section 4, Future Work) by allowing the width of a pipe to be different above
and below a subboard.

c. Pinch points and pipe width constraints

There are some scenarios in which the pipe width needs to be constrained in a
certain place. For example, in the nullness type system, when a variable is
dereferenced it must be nonnull. This means that we need a way to require balls
flowing through a pipe to be small in certain locations.

Our initial strategy was to place a pinch point in a variable's pipe whenever
values in it are required to be of the more restrictive of the two types in the
type system. However, in Autumn of 2012 (?), we agreed that we should remove the
pinch point mechanic in favor of a simpler one, at least for the nullness type
system (TODO: is it appropriate to adopt this in other type systems as well?):

In Java, whenever a variable is dereferenced, it is either for a field access or
a method call. Because we choose to represent field accesses as method calls
(see (d) Fields), we need only consider method calls. Whenever a method is
called, the receiver is essentially one of its arguments, except that it must be
nonnull, and this constraint is strictly enforced by the language runtime. We
represent this with a subboard that has a narrow input pipe for the receiver.
This causes a conflict to arise if the receiver's pipe is wide, since a wide
pipe is prohibited from flowing into a narrow one, as it may contain a large
ball.

Currently, both the trusted and nullness games use pinchpoints. This should be
changed in the nullness type system.

It may be possible to encode constraints for all relevant type systems without
using pinch points. If this is the case, it would be a good idea to remove pinch
points altogether for the sake of consistency. More discussion about this is
needed.

d. Fields

The problem of representing fields to players provides an interesting usability
challenge. In many ways, a field is like any other variable -- it has a type
that must be represented in the game, and it needs to be able to interact
normally with other variables. Thus, the most apparent solution is to simply
represent it as a pipe, just like any other variable.

If we represent fields as pipes, several requirements follow:

First, changing the pipe width in one location must also cause it to change in
another location. This is because a field cannot have different types in
different places (though Flow Sensitivity (4a) will allow us to bend this rule
in certain circumstances). In other words, a pipe representing a field must be
linked to every other occurrence of the field. This requirement holds even
across different boards, so when a player changes its width in one board, it is
also changed in another board. This mechanic may confusing to players.

Second, the pipes must begin and end somewhere. As we established above, pipes
for local variables begin when they are declared, and end when they go out of
scope. However, fields are inherently more global in scope -- they persist
beyond the scope of a method call. So it makes little sense for them to mimic
local variables and have their pipes start and end within each method. That
leaves us with only one other option: for field pipes to be both an input to and
output of a board. This is an appealing mechanic because it allows us to
simply represent the persistence of fields.

class Baz
{
  private String foo;

  public void method()
  {
    String bar = "hello world";
    System.out.println(foo.equals(bar));
  }
}

 (this)  (foo)
----------------------------
|  ||     | |              |
|  ||     | |   (bar)      |
|  ||     | |              |
|  ||     | |     o        |
|  ||     | |    | |       |
|  ||     \ /    | |       |
|  ||   --------------     |
|  ||   | String.    |     |
|  ||   | equals()   |     |
|  ||   --------------     |
|  ||     | |    | |       |
|  ||     | |    |_|       |
|  ||     | |              |
----------------------------

A sample class, and the board for "method" in the nullness type system with the
proposed field mechanic. Note the narrowing of the receiver pipe as it enters
the subboard for String.equals(), encoding the nonnull constraint for the
receiver of a method call.

Unfortunately, this representation has some major drawbacks. We claim in (b)
that the input pipes are made up of the receiver pipes and the argument pipes.
This representation contradicts that claim by adding additional input and output
pipes for every field in a class. This would not be a major problem except that
methods are sometimes called from outside a class. In this case, the subboard
would have inputs and outputs for the field, but what would the caller board
connect to these ports? It would not make sense for the caller board to have
pipes representing the callee's fields, especially if they were private. This
would break the fundamental purpose of abstractions, and it would make the game
incredibly difficult to scale.

Instead, what we elected to do was to generate accessor boards for every field
in a class, and have every field access appear to be a normal method call to a
simple accessor method, represented as a subboard. Under this system, the
example above would look like this:

  (this)
-----------------------------
|   ||                      |
|   ||                      |
|  ------------             |
|  | Baz.     |             |
|  | getFoo() |  (bar)      |
|  ------------             |
|   ||     | |     o        |
|   ||     | |    | |       |
|   ||     \ /    | |       |
|   ||   --------------     |
|   ||   | String.    |     |
|   ||   | equals()   |     |
|   ||   --------------     |
|   ||     | |    | |       |
|   ||     |_|    |_|       |
|   ||                      |
-----------------------------

The player can visit the Bax.getFoo() board, just as she can visit any ordinary
board, and by changing the width of the return pipe in that board, she changes
the field's type. This is reflected everywhere the field is accessed, and we
believe that because the accessor subboards are explicitly labeled, it will be
more obvious to the player when a change in one board affects another board.

This also satisfies the property that only the pipes for the receiver and the
arguments should be included as inputs to a board, and it make calls to other
classes much cleaner.

(TODO: find out what the current implementation actually does.)

e. Unsolvable games

buzzsaws

--------------------------------------------------------------------------------

3. Details of Code-to-game Conversion

problems with aliased arguments

back to annotations from solved game?

--------------------------------------------------------------------------------

4. Future Work

a. Flow Sensitivity

We plan to introduce flow sensitivity at some point in the future. In the
checker framework, flow sensitivity is the feature that allows types to be
refined after certain statements. Consider the following trivial example:

@Nullable String s = methodThatMayReturnNull();
if (s == null)
  System.out.println(s.hashCode());
else
  System.out.println(s.equals("foo"));

The nullness type system recognizes that the first dereference is not safe, but
that the second is, because the if statement tests the nullness of s.

We would like the game to also reflect this additional information. However, we
currently only allow variables to have a single unchanging type, represented by
linked pipes. Flow sensitivity would allow a single variable to have its pipes
in some locations unlinked from others. This would allow the game and the player
to be aware of the more precise type recognized by the nullness type system, as
in the above example.

keyfor

optimizer

new game style

--------------------------------------------------------------------------------

5. Glossary

Chute
  See pipe segment.

Edge
  Sometimes used to refer to a chute or pipe segment in the context of their
  graph representations.

Intersection
  A place where pipe segments interact. Examples include merges, splits, and
  subboards.

Pinch point
  A brief narrowing in a pipe through which a large ball cannot roll. Used to
  represent constraints in some type systems.

Pipe segment
  A single part of a pipe that runs uninterrupted from one intersection to
  another.
